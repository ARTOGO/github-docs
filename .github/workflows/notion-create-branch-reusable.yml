name: Notion â†’ GitHub Branch (Reusable)

on:
  workflow_call:
    inputs:
      repo_name:
        description: 'Repository name for Notion filter'
        required: true
        type: string
    secrets:
      NOTION_API_KEY:
        required: true
      NOTION_DATABASE_ID:
        required: true
      ANTHROPIC_API_KEY:
        required: true

jobs:
  create-branch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Query Notion and Process Tasks
        uses: actions/github-script@v7
        env:
          NOTION_API_KEY: ${{ secrets.NOTION_API_KEY }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO_NAME: ${{ inputs.repo_name }}
        with:
          script: |
            const notionKey = process.env.NOTION_API_KEY;
            const databaseId = process.env.NOTION_DATABASE_ID;
            const anthropicKey = process.env.ANTHROPIC_API_KEY;
            const repoName = process.env.REPO_NAME;
            
            // ========================================
            // åŠŸèƒ½ 1ï¼šè‡ªå‹•å»ºç«‹ Branch
            // ========================================
            console.log('=== åŠŸèƒ½ 1ï¼šè‡ªå‹•å»ºç«‹ Branch ===');
            
            const queryResponse = await fetch(`https://api.notion.com/v1/databases/${databaseId}/query`, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${notionKey}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                filter: {
                  and: [
                    { property: 'ä»»å‹™ç‹€æ…‹', status: { equals: 'DEV IN PROGRESS' } },
                    { property: 'GitHub Branch', rich_text: { is_empty: true } },
                    { property: 'GitHub Repo', select: { equals: repoName } }
                  ]
                }
              })
            });
            
            const data = await queryResponse.json();
            console.log(`[Create Branch] Found ${data.results?.length || 0} tasks for ${repoName}`);
            
            for (const page of data.results || []) {
              const taskIdObj = page.properties['Task ID'];
              const taskId = taskIdObj?.unique_id ? 
                `${taskIdObj.unique_id.prefix}-${taskIdObj.unique_id.number}` : null;
              const title = page.properties['é …ç›®']?.title?.[0]?.plain_text || 'untitled';
              const taskType = page.properties['ä»»å‹™é¡å‹']?.select?.name || 'ğŸ”¹ TASK';
              
              if (!taskId) {
                console.log('Skipping page without Task ID');
                continue;
              }
              
              console.log(`Processing: ${taskId} - ${title}`);
              
              // Claude API ç¿»è­¯
              let englishName = 'feature';
              try {
                const claudeResponse = await fetch('https://api.anthropic.com/v1/messages', {
                  method: 'POST',
                  headers: {
                    'x-api-key': anthropicKey,
                    'anthropic-version': '2023-06-01',
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    model: 'claude-3-haiku-20240307',
                    max_tokens: 100,
                    messages: [{
                      role: 'user',
                      content: `å°‡ä»¥ä¸‹ä¸­æ–‡åŠŸèƒ½åç¨±ç¿»è­¯æˆç°¡çŸ­çš„è‹±æ–‡ snake_case æ ¼å¼ï¼Œæœ€å¤š 30 å­—å…ƒï¼Œåªå›å‚³ç¿»è­¯çµæœï¼š\n\n${title}`
                    }]
                  })
                });
                
                const claudeData = await claudeResponse.json();
                englishName = claudeData.content?.[0]?.text?.trim()
                  .toLowerCase()
                  .replace(/[^a-z0-9_]/g, '_')
                  .replace(/_+/g, '_')
                  .substring(0, 30) || 'feature';
              } catch (e) {
                console.log(`Translation failed: ${e.message}`);
              }
              
              // Branch type
              let branchType = 'feat';
              if (taskType.includes('BUG')) branchType = 'fix';
              else if (taskType.includes('å°ˆæ¡ˆ')) branchType = 'project';
              
              const branchName = `${branchType}/${taskId}_${englishName}`;
              console.log(`Creating branch: ${branchName}`);
              
              // Create branch
              try {
                const defaultBranch = await github.rest.repos.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                
                const ref = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${defaultBranch.data.default_branch}`
                });
                
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/heads/${branchName}`,
                  sha: ref.data.object.sha
                });
                
                console.log(`Branch created: ${branchName}`);
              } catch (e) {
                if (e.status === 422) {
                  console.log(`Branch already exists: ${branchName}`);
                } else {
                  throw e;
                }
              }
              
              // Update Notion
              await fetch(`https://api.notion.com/v1/pages/${page.id}`, {
                method: 'PATCH',
                headers: {
                  'Authorization': `Bearer ${notionKey}`,
                  'Notion-Version': '2022-06-28',
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  properties: {
                    'GitHub Branch': { rich_text: [{ text: { content: branchName } }] }
                  }
                })
              });
              
              console.log(`Updated Notion with branch: ${branchName}`);
            }
            
            // ========================================
            // åŠŸèƒ½ 2ï¼šFunction Review å¤±æ•—é€šçŸ¥
            // ========================================
            console.log('=== åŠŸèƒ½ 2ï¼šFunction Review å¤±æ•—é€šçŸ¥ ===');
            
            const failedQuery = await fetch(`https://api.notion.com/v1/databases/${databaseId}/query`, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${notionKey}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                filter: {
                  and: [
                    { property: 'ä»»å‹™ç‹€æ…‹', status: { equals: 'FUNC REVIEW FAILED' } },
                    { property: 'GitHub Repo', select: { equals: repoName } }
                  ]
                }
              })
            });
            
            const failedData = await failedQuery.json();
            console.log(`[Func Review Failed] Found ${failedData.results?.length || 0} tasks for ${repoName}`);
            
            for (const page of failedData.results || []) {
              const taskIdObj = page.properties['Task ID'];
              const taskId = taskIdObj?.unique_id ? 
                `${taskIdObj.unique_id.prefix}-${taskIdObj.unique_id.number}` : null;
              const title = page.properties['é …ç›®']?.title?.[0]?.plain_text || 'untitled';
              const assignees = page.properties['æŒ‡æ´¾çµ¦']?.people || [];
              const prUrl = page.properties['GitHub PR']?.url || '';
              
              console.log(`Processing failed review: ${taskId} - ${title}`);
              
              // ç™¼é€é€šçŸ¥çµ¦é–‹ç™¼è€…
              if (assignees.length > 0) {
                const richText = [];
                
                for (let i = 0; i < assignees.length; i++) {
                  richText.push({
                    type: 'mention',
                    mention: {
                      type: 'user',
                      user: { id: assignees[i].id }
                    }
                  });
                  if (i < assignees.length - 1) {
                    richText.push({ type: 'text', text: { content: ' ' } });
                  }
                }
                
                richText.push({
                  type: 'text',
                  text: { content: ` Function Review æœªé€šéï¼Œè«‹é€²è¡Œèª¿æ•´å¾Œé‡æ–°é–‹ PR\nåŸ PR: ${prUrl}` }
                });
                
                const commentResponse = await fetch('https://api.notion.com/v1/comments', {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${notionKey}`,
                    'Notion-Version': '2022-06-28',
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    parent: { page_id: page.id },
                    rich_text: richText
                  })
                });
                
                if (commentResponse.ok) {
                  console.log(`Notified assignees: ${assignees.map(u => u.name || u.id).join(', ')}`);
                } else {
                  const error = await commentResponse.json();
                  console.error('Failed to add comment:', error);
                }
              }
              
              // æŠŠç‹€æ…‹æ”¹å› DEV IN PROGRESSï¼Œæ¸…ç©º PR ç›¸é—œæ¬„ä½
              await fetch(`https://api.notion.com/v1/pages/${page.id}`, {
                method: 'PATCH',
                headers: {
                  'Authorization': `Bearer ${notionKey}`,
                  'Notion-Version': '2022-06-28',
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  properties: {
                    'ä»»å‹™ç‹€æ…‹': { status: { name: 'DEV IN PROGRESS' } },
                    'PR Status': { select: null },
                    'GitHub PR': { url: null }
                  }
                })
              });
              
              console.log(`Reset status to DEV IN PROGRESS: ${taskId}`);
            }